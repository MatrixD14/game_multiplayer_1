class dangeonGeration extends Component { //[I-S]LN=0;[I-E]
  public class Cell { //[I-S]LN=1;[I-E]
    public boolean vision = false; //[I-S]LN=2;[I-E]
    public boolean[] status = new boolean[4]; //[I-S]LN=3;[I-E]
    public Point2 position; //[I-S]LN=4;[I-E]
 //[I-S]LN=5;[I-E]
    public Cell(int x, int z) { //[I-S]LN=6;[I-E]
      position = new Point2(x, z); //[I-S]LN=7;[I-E]
    } //[I-S]LN=8;[I-E]
  } //[I-S]LN=9;[I-E]
 //[I-S]LN=10;[I-E]
  public Point2 size = new Point2(); //[I-S]LN=11;[I-E]
  public int startPos = 0; //[I-S]LN=12;[I-E]
  public List<Cell> board; //[I-S]LN=13;[I-E]
  public ObjectFile room; //[I-S]LN=14;[I-E]
  public Point2 offset = new Point2(); //[I-S]LN=15;[I-E]
 //[I-S]LN=16;[I-E]
  void start() { //[I-S]LN=17;[I-E]
    armGerador(); //[I-S]LN=18;[I-E]
  } //[I-S]LN=19;[I-E]
 //[I-S]LN=20;[I-E]
  public void gerationDange() { //[I-S]LN=21;[I-E]
    for (int x = 0; x < size.x; x++) { //[I-S]LN=22;[I-E]
      for (int z = 0; z < size.y; z++) { //[I-S]LN=23;[I-E]
        Cell cellTmp = board.get(x + z * size.x); //[I-S]LN=24;[I-E]
        if (cellTmp.vision) { //[I-S]LN=25;[I-E]
          SpatialObject newRoom = myObject.instantiate(room, new Vector3(x * offset.x, 0, -z * offset.y)); //[I-S]LN=26;[I-E]
          // if (newRoom.findComponent("dangenBer")==null) newRoom.addComponent(new dangenBer()); //[I-S]LN=27;[I-E]
          dangenBer roomber = newRoom.findComponent("dangenBer"); //[I-S]LN=28;[I-E]
          if (roomber != null) roomber.UpdateRoom(cellTmp.status); //[I-S]LN=29;[I-E]
        } //[I-S]LN=30;[I-E]
      } //[I-S]LN=31;[I-E]
    } //[I-S]LN=32;[I-E]
  } //[I-S]LN=33;[I-E]
 //[I-S]LN=34;[I-E]
  public void armGerador() { //[I-S]LN=35;[I-E]
    board = new LinkedList<Cell>(); //[I-S]LN=36;[I-E]
    for (int z = 0; z < size.y; z++) { //[I-S]LN=37;[I-E]
      for (int x = 0; x < size.x; x++) { //[I-S]LN=38;[I-E]
        board.add(new Cell(x, z)); //[I-S]LN=39;[I-E]
      } //[I-S]LN=40;[I-E]
    } //[I-S]LN=41;[I-E]
    int currentCell = startPos; //[I-S]LN=42;[I-E]
    Deque<Integer> path = new ArrayDeque<Integer>(); //[I-S]LN=43;[I-E]
    int k = 0; //[I-S]LN=44;[I-E]
    while (k < 1000) { //[I-S]LN=45;[I-E]
      k++; //[I-S]LN=46;[I-E]
      board.get(currentCell).vision = true; //[I-S]LN=47;[I-E]
      if(currentCell == board.size()-1) break; //[I-S]LN=48;[I-E]
      List<Integer> neighbors = checkNeighbors(currentCell); //[I-S]LN=49;[I-E]
      if (neighbors.isEmpty()) { //[I-S]LN=50;[I-E]
        if (path.isEmpty()) break; //[I-S]LN=51;[I-E]
        currentCell = path.pop(); //[I-S]LN=52;[I-E]
        continue; //[I-S]LN=53;[I-E]
      } //[I-S]LN=54;[I-E]
      path.push(currentCell); //[I-S]LN=55;[I-E]
      int newCell = neighbors.get(Random.range(0, neighbors.size()-1)); //[I-S]LN=56;[I-E]
      if (newCell > currentCell) { //[I-S]LN=57;[I-E]
        if (newCell - 1 == currentCell) { //[I-S]LN=58;[I-E]
          board.get(currentCell).status[1] = true; //[I-S]LN=59;[I-E]
          currentCell = newCell; //[I-S]LN=60;[I-E]
          board.get(currentCell).status[3] = true; //[I-S]LN=61;[I-E]
        } else { //[I-S]LN=62;[I-E]
          board.get(currentCell).status[2] = true; //[I-S]LN=63;[I-E]
          currentCell = newCell; //[I-S]LN=64;[I-E]
          board.get(currentCell).status[0] = true; //[I-S]LN=65;[I-E]
        } //[I-S]LN=66;[I-E]
      } else { //[I-S]LN=67;[I-E]
        if (newCell + 1 == currentCell) { //[I-S]LN=68;[I-E]
          board.get(currentCell).status[3] = true; //[I-S]LN=69;[I-E]
          currentCell = newCell; //[I-S]LN=70;[I-E]
          board.get(currentCell).status[1] = true; //[I-S]LN=71;[I-E]
        } else { //[I-S]LN=72;[I-E]
          board.get(currentCell).status[0] = true; //[I-S]LN=73;[I-E]
          currentCell = newCell; //[I-S]LN=74;[I-E]
          board.get(currentCell).status[2] = true; //[I-S]LN=75;[I-E]
        } //[I-S]LN=76;[I-E]
      } //[I-S]LN=77;[I-E]
    } //[I-S]LN=78;[I-E]
    gerationDange(); //[I-S]LN=79;[I-E]
  } //[I-S]LN=80;[I-E]
 //[I-S]LN=81;[I-E]
  public List<Integer> checkNeighbors(int cell) { //[I-S]LN=82;[I-E]
    List<Integer> neighbors = new LinkedList<Integer>(); //[I-S]LN=83;[I-E]
    Point2 pos = board.get(cell).position; //[I-S]LN=84;[I-E]
 //[I-S]LN=85;[I-E]
    if (pos.y > 0 && !board.get(cell - size.x).vision) neighbors.add(cell - size.x); //[I-S]LN=86;[I-E]
 //[I-S]LN=87;[I-E]
    if (pos.y < size.y - 1 && !board.get(cell + size.x).vision) neighbors.add(cell + size.x); //[I-S]LN=88;[I-E]
 //[I-S]LN=89;[I-E]
    if (pos.x < size.x - 1 && !board.get(cell + 1).vision) neighbors.add(cell + 1); //[I-S]LN=90;[I-E]
 //[I-S]LN=91;[I-E]
    if (pos.x > 0 && !board.get(cell - 1).vision) neighbors.add(cell - 1); //[I-S]LN=92;[I-E]
 //[I-S]LN=93;[I-E]
    return neighbors; //[I-S]LN=94;[I-E]
  }  //[I-S]LN=95;[I-E]
} //[I-S]LN=96;[I-E]